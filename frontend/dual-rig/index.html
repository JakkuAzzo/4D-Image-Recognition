<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Dual Rig Live Viewer</title>
  <link rel="stylesheet" href="/static/styles.css" />
  <style>
    body{margin:0;background:#0b0b0b;color:#eaeaea;font-family:system-ui,-apple-system}
    header{padding:10px 16px;border-bottom:1px solid #222}
  .row{display:flex;gap:6px;align-items:center}
  .col{flex:1;position:relative;min-height:70vh}
  .col video{position:absolute;inset:0;width:100%;height:70vh;object-fit:cover;background:#000;z-index:0}
  .col canvas.feed{position:absolute;inset:0;width:100%;height:70vh;display:block;background:#000;z-index:1}
  .col canvas.overlay{position:absolute;inset:0;width:100%;height:70vh;display:block;background:transparent;z-index:2}
    .panel{padding:10px 16px;border-top:1px solid #222;display:flex;gap:12px;align-items:center}
    label{font-size:12px}
    input[type=range]{width:200px}
    .meter{min-width:160px}
    .hidden{display:none}
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r150/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/examples/js/loaders/OBJLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/examples/js/loaders/MTLLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4/face_mesh.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/selfie_segmentation.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>
  <script defer src="/static/nav.js"></script>
  
</head>
<body>
  <header>
    <div class="row">
      <div style="font-weight:600">Dual Rig Live Viewer</div>
  <div class="meter" id="similarity">Drive energy: --</div>
  <label>Privacy Î» <input id="lambda" type="range" min="0" max="1" step="0.05" value="0.6"></label>
      <label style="margin-left:10px;">Camera
        <select id="camera-select" style="background:#181818;color:#eaeaea;border:1px solid #333;border-radius:6px;padding:4px 8px;">
          <option value="">Default</option>
        </select>
      </label>
      <label style="margin-left:10px;">
        <input id="mirror-both" type="checkbox"> Mirror both </>
      </label>
      <label style="margin-left:10px;">Processing scale
        <select id="proc-scale" style="background:#181818;color:#eaeaea;border:1px solid #333;border-radius:6px;padding:4px 8px;">
          <option value="1">1.0x (full)</option>
          <option value="0.5">0.5x</option>
          <option value="0.33">0.33x</option>
        </select>
      </label>
    <label style="margin-left:10px;">Preset
        <select id="filter-preset" style="background:#181818;color:#eaeaea;border:1px solid #333;border-radius:6px;padding:4px 8px;">
          <option value="none">None</option>
      <option value="toon">Toon Avatar</option>
          <option value="appearance">Appearance (Hue + Headshape)</option>
          <option value="mask">Anon Mask</option>
          <option value="puppet">Custom Puppet</option>
        </select>
      </label>
      <label style="margin-left:10px;"><input id="apply-filter" type="checkbox" checked> Apply to Avatar feed</label>
  <button id="start">Start Camera</button>
  <button id="send-ext" title="Send current preset to the browser extension">Send to Extension</button>
  <span id="send-status" style="font-size:12px;opacity:.8"></span>
    </div>
  </header>
  <div class="row">
    <div class="col">
      <video id="video-truth" autoplay muted playsinline></video>
      <canvas id="truth" class="overlay"></canvas>
    </div>
    <div class="col">
      <video id="video-avatar" autoplay muted playsinline></video>
      <canvas id="avatar-feed" class="feed" style="display:none"></canvas>
      <canvas id="avatar" class="overlay"></canvas>
    </div>
  </div>
  <div class="panel" id="background-panel">
    <label>Background
      <select id="bg-mode" style="background:#181818;color:#eaeaea;border:1px solid #333;border-radius:6px;padding:4px 8px;">
        <option value="none">Original</option>
        <option value="blur">Blur</option>
        <option value="random">Random Color</option>
        <option value="image">Choose Image</option>
        <option value="generated">Generated</option>
      </select>
    </label>
    <input id="bg-file" type="file" accept="image/*" style="display:none" />
  </div>
  <div class="panel">
    <label><input id="keepScars" type="checkbox" checked> Keep scars</label>
    <label><input id="keepHair" type="checkbox" checked> Keep hair</label>
  </div>
  <div class="panel" id="filters-panel">
    <div id="controls-toon" class="ctrl-group hidden" style="gap:16px;flex-wrap:wrap">
      <label>Feature size <input id="toon-intensity" type="range" min="0.2" max="2.0" step="0.05" value="1.2"></label>
      <label>Filter FPS <input id="filter-fps-toon" type="number" min="5" max="60" step="1" value="18" style="width:64px;background:#181818;color:#eaeaea;border:1px solid #333;border-radius:6px;padding:3px 6px;"></label>
      <label><input id="toon-use-model" type="checkbox"> Use model stylizer</label>
  <label>Model URL <input id="toon-model-url" type="text" placeholder="/static/models/animegan2/model.json (or CDN)" style="min-width:300px;background:#181818;color:#eaeaea;border:1px solid #333;border-radius:6px;padding:3px 6px;"></label>
      <label>Input size
        <select id="toon-model-size" style="background:#181818;color:#eaeaea;border:1px solid #333;border-radius:6px;padding:3px 6px;">
          <option value="256">256</option>
          <option value="320">320</option>
          <option value="384">384</option>
          <option value="512">512</option>
        </select>
      </label>
      <label><input id="toon-norm" type="checkbox" checked> Normalize [-1,1]</label>
      <button id="toon-load">Load Model</button>
      <span id="toon-status" style="font-size:12px;color:#8fbcbb">Model: not loaded</span>
      <div style="flex-basis:100%;height:0"></div>
      <div id="toon-catalog-section" style="display:flex;gap:8px;flex-wrap:wrap;align-items:center">
        <label>Name <input id="toon-model-name" type="text" placeholder="My Stylizer" style="min-width:180px;background:#181818;color:#eaeaea;border:1px solid #333;border-radius:6px;padding:3px 6px;"></label>
        <button id="toon-save" title="Save current URL, size, and norm to catalog">Save to Catalog</button>
        <button id="toon-export" title="Export catalog to JSON">Export</button>
        <button id="toon-import" title="Import catalog from JSON">Import</button>
        <input id="toon-import-file" type="file" accept="application/json" style="display:none" />
      </div>
      <div id="toon-catalog" style="display:flex;flex-direction:column;gap:6px;max-height:180px;overflow:auto;background:#111;padding:8px;border:1px solid #333;border-radius:8px;min-width:420px">
        <!-- entries render here -->
      </div>
    </div>
    <div id="controls-appearance" class="ctrl-group hidden" style="gap:16px;flex-wrap:wrap">
      <div style="display:flex;flex-direction:column;gap:6px">
        <label>Hue shift (deg) <input id="appearance-hue-deg" type="range" min="-180" max="180" step="5" value="60"></label>
        <label><input id="appearance-skin-only" type="checkbox" checked> Skin-only hue</label>
        <label>Filter FPS <input id="filter-fps-appearance" type="number" min="5" max="60" step="1" value="24" style="width:64px;background:#181818;color:#eaeaea;border:1px solid #333;border-radius:6px;padding:3px 6px;"></label>
      </div>
      <div style="display:flex;flex-direction:column;gap:6px">
        <label>Head width <input id="head-w" type="range" min="0.6" max="1.6" step="0.02" value="1.2"></label>
        <label>Head height <input id="head-h" type="range" min="0.6" max="1.6" step="0.02" value="0.9"></label>
        <label>Nose warp <input id="nose-w" type="range" min="0.7" max="1.4" step="0.02" value="1.0"></label>
        <label>Mouth warp <input id="mouth-w" type="range" min="0.7" max="1.4" step="0.02" value="1.0"></label>
        <label><input id="freckles" type="checkbox"> Add freckles</label>
      </div>
    </div>
    <div id="controls-mask" class="ctrl-group hidden">
      <label>Color <input id="mask-color" type="color" value="#8a2be2" style="width:40px;height:24px;border:0;background:transparent;"></label>
      <label>Opacity <input id="mask-alpha" type="range" min="0.3" max="1" step="0.05" value="0.75"></label>
      <label>Filter FPS <input id="filter-fps-mask" type="number" min="5" max="60" step="1" value="30" style="width:64px;background:#181818;color:#eaeaea;border:1px solid #333;border-radius:6px;padding:3px 6px;"></label>
      <label><input id="mask-toon" type="checkbox"> Replace with Toon inside mask</label>
      <label>Morph <input id="mask-morph" type="range" min="0" max="1" step="0.05" value="0.6"></label>
    </div>
    <div id="controls-puppet" class="ctrl-group hidden" style="gap:16px;flex-wrap:wrap">
      <label>Puppet image <input id="puppet-file" type="file" accept="image/*" /></label>
      <label>Scale % <input id="puppet-scale" type="range" min="50" max="220" step="5" value="110"></label>
      <label>Opacity <input id="puppet-alpha" type="range" min="0.3" max="1" step="0.05" value="0.9"></label>
      <label><input id="puppet-follow" type="checkbox" checked> Follow rotation</label>
      <label>Filter FPS <input id="filter-fps-puppet" type="number" min="5" max="60" step="1" value="24" style="width:64px;background:#181818;color:#eaeaea;border:1px solid #333;border-radius:6px;padding:3px 6px;"></label>
  <div style="flex-basis:100%;height:0"></div>
  <label>Alpha mask <input id="puppet-mask-file" type="file" accept="image/*" /></label>
  <label><input id="puppet-mask-invert" type="checkbox"> Invert mask</label>
  <label>Edge feather (px) <input id="puppet-feather" type="range" min="0" max="40" step="1" value="12"></label>
  <div style="flex-basis:100%;height:0"></div>
  <label><input id="puppet-dyn-blend" type="checkbox"> Blend by motion</label>
  <label>Min alpha <input id="puppet-alpha-min" type="range" min="0" max="1" step="0.05" value="0.6"></label>
  <label>Max alpha <input id="puppet-alpha-max" type="range" min="0.2" max="1" step="0.05" value="0.95"></label>
    </div>
  </div>
  <div class="panel" id="character-panel">
  <label>Truth model <input id="truth-upload" type="file" accept=".glb,.gltf,.obj,model/gltf-binary,model/gltf+json,model/obj" /></label>
  <label>Avatar model <input id="avatar-upload" type="file" accept=".glb,.gltf,.obj,model/gltf-binary,model/gltf+json,model/obj" /></label>
    <label>CGTrader avatars
      <select id="cgtrader-list" style="background:#181818;color:#eaeaea;border:1px solid #333;border-radius:6px;padding:4px 8px;min-width:300px">
        <option value="">â browse â</option>
      </select>
    </label>
  <button id="cgtrader-refresh" title="Reload list of avatars">Refresh</button>
    <button id="reset-models">Reset to placeholder</button>
  <span id="rig-status" style="font-size:12px;opacity:.8"></span>
  </div>
  <video id="video" style="display:none" muted playsinline></video>

<script>
function _loadScript(src){return new Promise((res,rej)=>{const s=document.createElement('script');s.src=src;s.onload=()=>res(true);s.onerror=rej;document.head.appendChild(s);});}
async function _ensureThree(){
  if (window.THREE) return;
  try { await _loadScript('https://unpkg.com/three@0.150.0/build/three.min.js'); }
  catch(e){ console.error('Three.js failed to load', e); }
  if (!window.THREE) throw new Error('Three.js unavailable');
  if (!THREE.OrbitControls) {
    try { await _loadScript('https://cdn.jsdelivr.net/npm/three@0.150.0/examples/js/controls/OrbitControls.js'); } catch(e){}
  }
  if (!THREE.GLTFLoader) {
    try { await _loadScript('https://cdn.jsdelivr.net/npm/three@0.150.0/examples/js/loaders/GLTFLoader.js'); } catch(e){}
  }
  if (!THREE.OBJLoader) {
    try { await _loadScript('https://cdn.jsdelivr.net/npm/three@0.150.0/examples/js/loaders/OBJLoader.js'); } catch(e){}
  }
  if (!THREE.MTLLoader) {
    try { await _loadScript('https://cdn.jsdelivr.net/npm/three@0.150.0/examples/js/loaders/MTLLoader.js'); } catch(e){}
  }
}

// Minimal ARKit-like subset mapping from landmarks
const channels = ["jawOpen","mouthSmile_L","mouthSmile_R","eyeBlinkLeft","eyeBlinkRight","browInnerUp"]; // demo subset

function landmarksToCoeffs(landmarks){
  if(!landmarks || !landmarks.length) return {};
  const lm = landmarks[0];
  const get = i => lm[i];
  // Very rough proxies for demo purposes
  const mouthOpen = () => Math.max(0, (get(13).y - get(14).y) * 5.0);
  const smileL = () => Math.max(0, (get(61).x - get(50).x) * 5.0);
  const smileR = () => Math.max(0, (get(280).x - get(290).x) * 5.0);
  const blinkL = () => Math.max(0, (get(159).y - get(145).y) * -15.0);
  const blinkR = () => Math.max(0, (get(386).y - get(374).y) * -15.0);
  const browUp  = () => Math.max(0, (get(55).y - get(65).y) * -5.0);
  return {
    jawOpen: clamp(mouthOpen(),0,1),
    mouthSmile_L: clamp(smileL(),0,1),
    mouthSmile_R: clamp(smileR(),0,1),
    eyeBlinkLeft: clamp(blinkL(),0,1),
    eyeBlinkRight: clamp(blinkR(),0,1),
    browInnerUp: clamp(browUp(),0,1)
  };
}

function clamp(v,min,max){return Math.max(min, Math.min(max,v));}

// Three.js setup for two scenes
function setupCanvas(canvasId){
  const canvas = document.getElementById(canvasId);
  const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
  const scene = new THREE.Scene(); scene.background = new THREE.Color(0x0b0b0b);
  const camera = new THREE.PerspectiveCamera(50, 2, 0.1, 100);
  camera.position.set(0, 0.2, 1.8);
  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  const light = new THREE.DirectionalLight(0xffffff, 1.0); light.position.set(1,1,1); scene.add(light);
  scene.add(new THREE.AmbientLight(0x888888));
  function resize(){
    const w = canvas.clientWidth, h = canvas.clientHeight; renderer.setSize(w,h,false); camera.aspect=w/h; camera.updateProjectionMatrix();
  }
  window.addEventListener('resize', resize); resize();
  return {renderer, scene, camera, controls};
}

// Can only setup canvases once THREE is loaded
let truth, avatar;

let truthRig=null, avatarRig=null;
// Retarget caches per rig
const RETARGET = new WeakMap(); // rigRoot -> { bones: {jaw, head, eyeL, eyeR, browL, browR}, rest: Map(bone-> {pos,rot}) }

function loadRig(url, target){
  return new Promise((resolve)=>{
    // Choose loader by extension
    loadModelFromUrl(url, (g)=>{ const node=g.scene||g; target.scene.add(node); resolve(node); }, ()=>{
      // Fallback primitive head-like mesh
      const geo = new THREE.IcosahedronGeometry(0.8, 3);
      const mat = new THREE.MeshStandardMaterial({color:0x88aaff, roughness:0.6, metalness:0.05});
      const m = new THREE.Mesh(geo, mat);
      const group = new THREE.Group(); group.add(m);
      target.scene.add(group);
      resolve(group);
    });
  });
}

function loadModelFromUrl(url, onLoaded, onError){
  try{
    const clean = (url||'').split('?')[0].split('#')[0];
    const ext = clean.substring(clean.lastIndexOf('.')+1).toLowerCase();
    if (ext === 'glb' || ext === 'gltf'){
      new THREE.GLTFLoader().load(url, (g)=>onLoaded(g), undefined, (e)=>{ console.error('GLTF load failed', e); onError && onError(e); });
      return;
    }
    if (ext === 'obj'){
      return loadObjWithOptionalMtl(url, onLoaded, onError);
    }
    throw new Error('Unsupported model type: '+ext);
  }catch(e){ console.error(e); onError && onError(e); }
}

function loadObjWithOptionalMtl(url, onLoaded, onError){
  const idx = url.lastIndexOf('/');
  const basePath = idx>=0 ? url.substring(0, idx+1) : '';
  const fileName = idx>=0 ? url.substring(idx+1) : url;
  const mtlGuess = fileName.replace(/\.obj$/i, '.mtl');
  const mtlUrl = basePath + mtlGuess;
  const tryMtl = () => {
    if (!THREE.MTLLoader) return Promise.reject(new Error('MTLLoader missing'));
    return new Promise((resolve, reject)=>{
      const mtl = new THREE.MTLLoader();
      if (basePath) mtl.setPath(basePath);
      mtl.load(mtlGuess, (materials)=>{ try{ materials.preload(); resolve(materials); }catch(err){ resolve(null); } }, undefined, ()=>resolve(null));
    });
  };
  tryMtl().then((materials)=>{
    const loader = new THREE.OBJLoader();
    if (materials) loader.setMaterials(materials);
    if (basePath) loader.setPath(basePath);
    loader.load(fileName, (group)=>{ onLoaded && onLoaded(group); }, undefined, (e)=>{ console.error('OBJ load failed', e); onError && onError(e); });
  }).catch(()=>{
    const loader = new THREE.OBJLoader();
    loader.load(url, (group)=>{ onLoaded && onLoaded(group); }, undefined, (e)=>{ console.error('OBJ load failed', e); onError && onError(e); });
  });
}

function replaceTruthRig(g){
  try{ if (truthRig){ truth.scene.remove(truthRig); } }catch(e){}
  const node = g.scene || g; truth.scene.add(node); truthRig = node;
  try{ discoverBones(truthRig); }catch(e){ console.warn('Retarget discovery failed (truth)', e); }
  updateRigStatus();
}
function replaceAvatarRig(g){
  try{ if (avatarRig){ avatar.scene.remove(avatarRig); } }catch(e){}
  const node = g.scene || g; avatar.scene.add(node); avatarRig = node;
  try{ discoverBones(avatarRig); }catch(e){ console.warn('Retarget discovery failed (avatar)', e); }
  updateRigStatus();
}

(async function init(){
  try { await _ensureThree(); } catch(e){ console.error(e); return; }
  // Now that THREE is available, setup canvases
  truth = setupCanvas('truth');
  avatar = setupCanvas('avatar');
  // Try to load existing exports; if not found, load a placeholder head
  const truthUrl = '/static/placeholder_head.glb';
  const avatarUrl = '/static/placeholder_head.glb';
  truthRig = await loadRig(truthUrl, truth);
  avatarRig = await loadRig(avatarUrl, avatar);

  function tick(){
    requestAnimationFrame(tick);
    truth.controls.update(); avatar.controls.update();
    truth.renderer.render(truth.scene, truth.camera);
    avatar.renderer.render(avatar.scene, avatar.camera);
  }
  tick();
})();

// Driving both rigs with MediaPipe FaceMesh
const videoTruth = document.getElementById('video-truth');
const videoAvatar = document.getElementById('video-avatar');
const avatarFeed = document.getElementById('avatar-feed');
const avatarOverlay = document.getElementById('avatar');
const hiddenVideo = document.getElementById('video');
const startBtn = document.getElementById('start');
const cameraSelect = document.getElementById('camera-select');
const mirrorBoth = document.getElementById('mirror-both');
const procScaleSel = document.getElementById('proc-scale');
const presetSel = document.getElementById('filter-preset');
const applyFilterChk = document.getElementById('apply-filter');

let currentStream = null;
let processing = false;
let fmInstance = null;
let fmBusy = false;
let rafId = null;
let currentScale = 1;
const procCanvas = document.createElement('canvas');
const procCtx = procCanvas.getContext('2d');
let lastLandmarks = null;
let lastCoeffs = {};
let filterTimer = 0;
let filterFps = 24;
const feedCtx = avatarFeed.getContext('2d');
const lambdaSlider = document.getElementById('lambda');
// TF.js stylizer state
let toonModel = null;
let toonBusy = false;
const toonUseModel = () => document.getElementById('toon-use-model').checked;
const toonModelUrlEl = () => document.getElementById('toon-model-url');
const toonModelSizeEl = () => document.getElementById('toon-model-size');
const toonNormEl = () => document.getElementById('toon-norm');
const toonStatusEl = () => document.getElementById('toon-status');
// Background replacement state
const bgModeSel = document.getElementById('bg-mode');
const bgFileInput = document.getElementById('bg-file');
let bgImage = null; // HTMLImageElement for chosen image
let segInstance = null; let segBusy = false;
const segCanvas = document.createElement('canvas');
const segCtx = segCanvas.getContext('2d');
let segMaskReady = false;
function ensureSegCanvasSize(w,h){ if(segCanvas.width!==w||segCanvas.height!==h){ segCanvas.width=w; segCanvas.height=h; } }
function smoothstep(edge0, edge1, x){ const t = Math.min(1, Math.max(0, (x-edge0)/Math.max(1e-6, edge1-edge0))); return t*t*(3-2*t); }

async function listCameras(){
  try{
    const devices = await navigator.mediaDevices.enumerateDevices();
    const vids = devices.filter(d=>d.kind==='videoinput');
    cameraSelect.innerHTML = '<option value="">Default</option>' + vids.map(d=>`<option value="${d.deviceId}">${d.label||'Camera'}</option>`).join('');
  }catch(e){ /* ignore */ }
}

function applyMirror(){
  const t = mirrorBoth.checked ? 'scaleX(-1)' : '';
  videoTruth.style.transform = t;
  videoAvatar.style.transform = t;
  avatarFeed.style.transform = t;
}

async function startWithDevice(deviceId){
  // stop prior
  if (currentStream){ currentStream.getTracks().forEach(t=>t.stop()); currentStream = null; }
  const base = { width:{ideal:1280}, height:{ideal:720}, facingMode:'user' };
  const constraints = { video: deviceId ? { ...base, deviceId: { exact: deviceId } } : base, audio: false };
  const stream = await navigator.mediaDevices.getUserMedia(constraints);
  videoTruth.srcObject = stream; videoAvatar.srcObject = stream; hiddenVideo.srcObject = stream; currentStream = stream;
}

function stopStream(){ if (!currentStream) return; try{ currentStream.getTracks().forEach(t=>t.stop()); }catch(e){} currentStream=null; }

function ensureFaceMesh(){
  if (fmInstance) return fmInstance;
  fmInstance = new FaceMesh({locateFile: (f)=>`https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}`} );
  fmInstance.setOptions({maxNumFaces:1, refineLandmarks:true, minDetectionConfidence:0.6, minTrackingConfidence:0.5});
  return fmInstance;
}

async function processFrame(){
  if (!processing || !hiddenVideo.videoWidth) return;
  if (fmBusy) return; fmBusy = true;
  try{
    const W = Math.floor(hiddenVideo.videoWidth * currentScale);
    const H = Math.floor(hiddenVideo.videoHeight * currentScale);
    procCanvas.width = W; procCanvas.height = H;
    procCtx.drawImage(hiddenVideo, 0, 0, W, H);
    const image = procCtx.getImageData(0,0,W,H);
    const fm = ensureFaceMesh();
    const res = await fm.send({image});
  }catch(e){ /* mediapipe handles its own pipeline */ }
  finally{ fmBusy = false; }
}

function drawOverlay(ctx, coeffs){
  ctx.clearRect(0,0,ctx.canvas.width, ctx.canvas.height);
  ctx.save();
  ctx.fillStyle = 'rgba(138,43,226,0.15)';
  ctx.strokeStyle = 'rgba(138,43,226,0.9)';
  ctx.lineWidth = 3;
  const cx = ctx.canvas.width/2, cy = ctx.canvas.height/2;
  const jaw = coeffs.jawOpen||0, smile=(coeffs.mouthSmile_L+coeffs.mouthSmile_R)/2;
  ctx.beginPath();
  ctx.ellipse(cx, cy, 120+smile*40, 160+jaw*60, 0, 0, Math.PI*2);
  ctx.fill(); ctx.stroke();
  ctx.restore();
}

function updateRigStatus(){
  const s = [];
  if (truthRig) s.push('truth');
  if (avatarRig) s.push('avatar');
  document.getElementById('rig-status').textContent = 'Rigs: '+ (s.join(', ')||'none');
}

function discoverBones(root){
  // placeholder; in practice we'd locate relevant bones or nodes to drive
  RETARGET.set(root, { bones: {}, rest: new Map() });
}

function retargetRig(root, coeffs){
  const R = RETARGET.get(root); if (!R) return;
  // placeholder simple head nod and jaw open based on coeffs
  const nod = (coeffs.browInnerUp||0) * 0.25;
  if (root && root.rotation) root.rotation.x = -nod;
}

function sendToExtension(preset){
  try{
    window.postMessage({ type:'IDENTITY_FILTER_PRESET', preset }, '*');
    document.getElementById('send-status').textContent = 'Sent preset to extension';
  }catch(e){ document.getElementById('send-status').textContent = 'Failed to send to extension'; }
}

function choosePreset(name){
  const p = { name };
  if (name==='toon'){
    p.type='stylize';
    p.params={ modelUrl: (toonModelUrlEl().value||'').trim(), size: parseInt(toonModelSizeEl().value||'256'), norm: !!toonNormEl().checked };
  } else if (name==='appearance'){
    p.type='appearance'; p.params={ hueDeg: parseInt(document.getElementById('appearance-hue-deg').value||'0'), skinOnly: !!document.getElementById('appearance-skin-only').checked };
  } else if (name==='mask'){
    p.type='mask'; p.params={ color: document.getElementById('mask-color').value, alpha: parseFloat(document.getElementById('mask-alpha').value||'0.7'), toonInside: !!document.getElementById('mask-toon').checked, morph: parseFloat(document.getElementById('mask-morph').value||'0.5') };
  } else if (name==='puppet'){
    p.type='puppet'; p.params={ scale: parseInt(document.getElementById('puppet-scale').value||'100'), alpha: parseFloat(document.getElementById('puppet-alpha').value||'0.9'), follow: !!document.getElementById('puppet-follow').checked };
  }
  return p;
}

function onPresetChange(){
  const name = presetSel.value;
  document.querySelectorAll('.ctrl-group').forEach(el=>el.classList.add('hidden'));
  filterFps = 24;
  if (name==='toon'){
    document.getElementById('controls-toon').classList.remove('hidden');
    filterFps = parseInt(document.getElementById('filter-fps-toon').value||'18');
  } else if (name==='appearance'){
    document.getElementById('controls-appearance').classList.remove('hidden');
    filterFps = parseInt(document.getElementById('filter-fps-appearance').value||'24');
  } else if (name==='mask'){
    document.getElementById('controls-mask').classList.remove('hidden');
    filterFps = parseInt(document.getElementById('filter-fps-mask').value||'30');
  } else if (name==='puppet'){
    document.getElementById('controls-puppet').classList.remove('hidden');
    filterFps = parseInt(document.getElementById('filter-fps-puppet').value||'24');
  }
}

function onApplyFilterChanged(){
  avatarFeed.style.display = applyFilterChk.checked ? 'block' : 'none';
}

document.getElementById('toon-load').addEventListener('click', async ()=>{
  try{
    const url = (toonModelUrlEl().value||'').trim();
    if (!url){ toonStatusEl().textContent = 'Enter model URL'; return; }
    toonStatusEl().textContent = 'Loading...';
    toonModel = await tf.loadGraphModel(url);
    toonStatusEl().textContent = 'Loaded TF.js model';
  }catch(e){ console.error(e); toonStatusEl().textContent = 'Load failed'; }
});

document.getElementById('toon-save').addEventListener('click', ()=>{
  try{
    const name = (document.getElementById('toon-model-name').value||'').trim();
    if (!name) return;
    const item = {
      name,
      url: (toonModelUrlEl().value||'').trim(),
      size: parseInt(toonModelSizeEl().value||'256'),
      norm: !!toonNormEl().checked
    };
    const list = JSON.parse(localStorage.getItem('toon-catalog')||'[]');
    list.push(item);
    localStorage.setItem('toon-catalog', JSON.stringify(list));
    renderToonCatalog();
  }catch(e){}
});

document.getElementById('toon-export').addEventListener('click', ()=>{
  try{
    const list = localStorage.getItem('toon-catalog')||'[]';
    const blob = new Blob([list], {type:'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href=url; a.download='toon-catalog.json'; a.click(); URL.revokeObjectURL(url);
  }catch(e){}
});

document.getElementById('toon-import').addEventListener('click', ()=>{
  document.getElementById('toon-import-file').click();
});
document.getElementById('toon-import-file').addEventListener('change', (e)=>{
  const file = e.target.files && e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = ()=>{
    try{ localStorage.setItem('toon-catalog', String(reader.result||'[]')); renderToonCatalog(); }catch(e){}
  };
  reader.readAsText(file);
});

function renderToonCatalog(){
  try{
    const list = JSON.parse(localStorage.getItem('toon-catalog')||'[]');
    const root = document.getElementById('toon-catalog');
    root.innerHTML = '';
    for (const item of list){
      const row = document.createElement('div');
      row.style.display='flex'; row.style.alignItems='center'; row.style.gap='8px';
      row.innerHTML = `<span style="flex:1">${item.name}</span>`+
        `<button data-act="use">Use</button>`+
        `<button data-act="del">Delete</button>`;
      row.querySelector('[data-act=use]').addEventListener('click', ()=>{
        toonModelUrlEl().value = item.url||'';
        toonModelSizeEl().value = String(item.size||'256');
        toonNormEl().checked = !!item.norm;
      });
      row.querySelector('[data-act=del]').addEventListener('click', ()=>{
        const list2 = (list||[]).filter(x=>x!==item);
        localStorage.setItem('toon-catalog', JSON.stringify(list2));
        renderToonCatalog();
      });
      root.appendChild(row);
    }
  }catch(e){}
}

function ensureSegmentation(){
  if (segInstance) return segInstance;
  segInstance = new SelfieSegmentation({locateFile: (f)=>`https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${f}`} );
  segInstance.setOptions({ modelSelection: 1 });
  return segInstance;
}

async function processSegmentation(){
  if (!applyFilterChk.checked) return;
  if (!hiddenVideo.videoWidth) return;
  if (segBusy) return; segBusy = true;
  try{
    ensureSegCanvasSize(hiddenVideo.videoWidth, hiddenVideo.videoHeight);
    const s = ensureSegmentation();
    await s.send({image: hiddenVideo});
    // In real impl, read back mask from s; here just track readiness flag
    segMaskReady = true;
  }catch(e){}
  finally{ segBusy = false; }
}

function applyBackground(){
  if (!applyFilterChk.checked) return;
  const mode = bgModeSel.value;
  if (mode==='none') return;
  try{
    const w = avatarFeed.width = hiddenVideo.videoWidth;
    const h = avatarFeed.height = hiddenVideo.videoHeight;
    feedCtx.drawImage(hiddenVideo, 0, 0, w, h);
    if (mode==='blur'){
      // simple separable blur approximation by scaling down/up
      const tmp = document.createElement('canvas'); const tctx = tmp.getContext('2d');
      tmp.width = Math.floor(w/12); tmp.height = Math.floor(h/12);
      tctx.drawImage(avatarFeed, 0, 0, tmp.width, tmp.height);
      feedCtx.imageSmoothingEnabled = true;
      feedCtx.drawImage(tmp, 0, 0, tmp.width, tmp.height, 0, 0, w, h);
    } else if (mode==='random'){
      feedCtx.fillStyle = `hsl(${Math.floor(Math.random()*360)}, 45%, 40%)`;
      feedCtx.fillRect(0,0,w,h);
    } else if (mode==='image' && bgImage){
      feedCtx.drawImage(bgImage, 0, 0, w, h);
    }
  }catch(e){}
}

async function runLoop(){
  if (!processing) return;
  try{
    await processFrame();
    await processSegmentation();
    // Retarget rigs from lastCoeffs (placeholder mapping for demo)
    retargetRig(truthRig, lastCoeffs);
    retargetRig(avatarRig, lastCoeffs);
    drawOverlay(avatarOverlay.getContext('2d'), lastCoeffs);
  }catch(e){}
  finally{
    rafId = requestAnimationFrame(runLoop);
  }
}

async function onStart(){
  try{
    await listCameras();
    await startWithDevice(cameraSelect.value||'');
    processing = true;
    onPresetChange();
    onApplyFilterChanged();
    runLoop();
  }catch(e){ console.error(e); }
}

cameraSelect.addEventListener('change', ()=>{ startWithDevice(cameraSelect.value||''); });
mirrorBoth.addEventListener('change', applyMirror);
procScaleSel.addEventListener('change', ()=>{ currentScale = parseFloat(procScaleSel.value||'1'); });
startBtn.addEventListener('click', onStart);
presetSel.addEventListener('change', onPresetChange);
applyFilterChk.addEventListener('change', onApplyFilterChanged);

document.getElementById('bg-mode').addEventListener('change', ()=>{
  if (bgModeSel.value==='image') document.getElementById('bg-file').click();
});

document.getElementById('bg-file').addEventListener('change', (e)=>{
  const f = e.target.files && e.target.files[0];
  if (!f) return;
  const img = new Image();
  img.onload = ()=>{ bgImage = img; };
  img.src = URL.createObjectURL(f);
});

document.getElementById('truth-upload').addEventListener('change', async (e)=>{
  const f = e.target.files && e.target.files[0];
  if (!f) return;
  try{
    replaceTruthRig(await loadModelFromFile(f));
  }catch(e){}
});

document.getElementById('avatar-upload').addEventListener('change', async (e)=>{
  const f = e.target.files && e.target.files[0];
  if (!f) return;
  try{
    replaceAvatarRig(await loadModelFromFile(f));
  }catch(e){}
});

document.getElementById('reset-models').addEventListener('click', async ()=>{
  try{
    replaceTruthRig(await loadRig('/static/placeholder_head.glb', truth));
    replaceAvatarRig(await loadRig('/static/placeholder_head.glb', avatar));
  }catch(e){}
});

document.getElementById('send-ext').addEventListener('click', ()=>{
  const p = choosePreset(presetSel.value);
  sendToExtension(p);
});

function loadModelFromFile(file){
  return new Promise((resolve,reject)=>{
    try{
      const ext = file.name.substring(file.name.lastIndexOf('.')+1).toLowerCase();
      const url = URL.createObjectURL(file);
      if (ext==='glb' || ext==='gltf'){
        new THREE.GLTFLoader().load(url, (g)=>{ URL.revokeObjectURL(url); resolve(g); }, undefined, (e)=>{ URL.revokeObjectURL(url); reject(e); });
        return;
      }
      if (ext==='obj'){
        const reader = new FileReader();
        reader.onload = ()=>{
          const text = String(reader.result||'');
          const group = new THREE.OBJLoader().parse(text);
          resolve(group);
        };
        reader.readAsText(file);
        return;
      }
      reject(new Error('Unsupported model type'));
    }catch(e){ reject(e); }
  });
}
</script>
</body>
</html>
